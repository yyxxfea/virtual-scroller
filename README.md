# virtual-scroller

## 运行逻辑说明

-   有滚动条时，通过前后插入带高度的空白区域来撑大，只渲染一部分数据。
    -   别的方式，可以通过绝对定位 + translateY(frontOffset) 来，但这样的结构适配不了表格。
    -   前后项的空白高度初始是用 `一项的最小高度 × 数量` 来计算，并在加载后保存起实际高度
-   加入了分页的概念，n 个数据为一页
    -   保存实际高度时是以“**页**”为单位
    -   滚动距离变化时，以“**页**”为单位变化视图
-   列表有一个包裹层，来保证奇偶性正确
-   浏览器机制：scrollTop 在前部分插入东西会自适应，使视图相不变（浏览器之间表现不一样，比如原 Edge 是不行的）
    -   DOM 某些破坏性更新时，此机制不生效
    -   事实上这里的实现，没有利用并需要避开这个机制
-   prepend（前插）数据时，为了让旧的分页范围相对不变，将向前延伸而不是全部重新分页
    -   是为了实现前插数据后，保持视图相对不动
    -   所以前插数据后，第一页可能数量不饱和（最后一页也是）

## todo/issues

-   写 types 描述文件

-   #1(fixed) 当slot.after 存在时，滚动条在最底时，appendData 时浏览器会尝试自适应保持在最底
    1.   在 slot.after 上加动态 key 也能避免，但会使其每次 render 都重新跑，也不可行。所以换成在最底部加一个不停更新 key 值的空元素。
    2.   曾试过另一种方案：更新完手动控制 scrollTop 回到原本的位置，正常是可行的。但谷歌浏览器（假如不做步骤 1，不论是否使用方案 2）有神奇的 bug，拖到最后加下加载完，竟然会影响到外部的滚动条，在客服中心的聊天监控能重现。具体表现：本组件上部分出现在可视区域外，滚动条拖到最后并向下加载，数据出现后，外面不关事的主容器滚动条向下滚了。
-   #2 如何实现 scrollTo(固定高度) scrollToIndex(下标)
-   #3 为了性能考虑，是否应该把行的内置 css 添加逻辑，移到外部传入的 renderItem 中（强制性，内部逻辑依赖此类名）
-   #4 若中途删除了一条、几条、未知数量的数据，怎么办？若同时希望保留恰当的滚动距离？
-   #5 若**持续拖动滚动条**，向前加载未加载过的数据（即未曾保存实际高度）时，因实际高度变更，为了使视图相对不变，理论上做了视图偏移兼容，但实际上还是会出现滚动距离突变
    -   以 scrollTop 为例，数值变化依次是：2758 -> 2656 -> 2579 -> 2477 -> 3142(页码变更，偏移计算后主动改变了 scrollTop) -> 2458(但由于连续拖动滚动条，这次依然是根据上上次的滚动距离来表现) -> 2403
    -   向后滚动来加载未加载过的数据时也会（火狐）
-   #6 未兼容横向滚动
